#include <pebble.h>
#include <math.h>
#include <string.h>
#include "message_keys.auto.h"
#include "yes_types.h"
#include "yes_astro.h"
#include "yes_draw.h"

// Pebble/newlib toolchain can omit errno plumbing; libm references __errno for some functions.
// Provide a minimal stub to satisfy the linker.
int *__errno(void) {
  static int e;
  return &e;
}

static Window *s_window;
static Layer *s_canvas_layer;
static AppTimer *s_startup_timer;
static bool s_debug;

// --- Watch-side fallback computations ---
// This is now libm-free (uses Pebble fixed-point trig in yes_astro.c), so we can keep
// a single code path across emulator + real watch (including Basalt).

// AppMessage keys are generated by pebble-tool into `message_keys.auto.h` / `message_keys.auto.c`.

// --- Persist keys ---
enum {
  // HOME (current phone location)
  PERSIST_HOME_LAT_E6 = 100,
  PERSIST_HOME_LON_E6 = 101,
  PERSIST_HOME_TZ_OFFSET_MIN = 102,

  // Cached daily events (computed on phone when available; otherwise computed on-watch as fallback)
  PERSIST_HOME_YMD = 120, // yyyymmdd in local time for HOME tz
  PERSIST_HOME_SUN_STATE = 121, // 0 normal, 1 always day, 2 always night, 3 invalid
  PERSIST_HOME_SUNRISE_MIN = 122,
  PERSIST_HOME_SUNSET_MIN = 123,
  PERSIST_HOME_MOON_STATE = 124, // 0 normal, 1 always up, 2 always down, 3 invalid
  PERSIST_HOME_MOONRISE_MIN = 125,
  PERSIST_HOME_MOONSET_MIN = 126,
  PERSIST_HOME_MOON_PHASE_E6 = 127,

  // Debug/behavior flags (sent from phone config)
  PERSIST_USE_INTERNET_FALLBACK = 140,
};

static GeoLoc s_home;
static bool s_use_internet_fallback;

static SunTimes s_sun_home;

static MoonTimes s_moon_home;
static int32_t s_moon_phase_e6;
static bool s_have_moon_phase;

static int s_last_calc_year = -1;
static int s_last_calc_month = -1;
static int s_last_calc_day = -1;

// Cached daily event stamp (yyyymmdd)
static int s_home_ymd = 0;

// Fallback computation timer state
static AppTimer *s_fallback_calc_timer;
typedef enum {
  CALC_PHASE_NONE = 0,
  CALC_PHASE_HOME_SUN,
} CalcPhase;
static CalcPhase s_calc_phase = CALC_PHASE_NONE;

// Note: we no longer calculate sunrise/moonrise on-watch (too expensive on emulator/slow paths).
// Phone-side JS computes and sends event times; the watch only renders.

static const GeoLoc* active_loc(void) {
  return &s_home;
}

static const SunTimes* active_sun(void) {
  return &s_sun_home;
}

static const MoonTimes* active_moon(void) {
  return &s_moon_home;
}

static void clear_events(void) {
  s_sun_home = (SunTimes){0};
  s_moon_home = (MoonTimes){0};
}

static void set_sun_from_state_and_minutes(SunTimes *sun, int state, int sunrise_min, int sunset_min) {
  *sun = (SunTimes){0};
  sun->valid = (state != 3);
  sun->always_day = (state == 1);
  sun->always_night = (state == 2);
  sun->sunrise_min = sunrise_min;
  sun->sunset_min = sunset_min;
}

static void set_moon_from_state_and_minutes(MoonTimes *moon, int state, int moonrise_min, int moonset_min) {
  *moon = (MoonTimes){0};
  moon->valid = (state != 3);
  moon->always_up = (state == 1);
  moon->always_down = (state == 2);
  moon->moonrise_min = moonrise_min;
  moon->moonset_min = moonset_min;
}

static int sun_state_from_struct(const SunTimes *sun) {
  if (!sun || !sun->valid) return 3;
  if (sun->always_day) return 1;
  if (sun->always_night) return 2;
  return 0;
}

static int moon_state_from_struct(const MoonTimes *moon) {
  if (!moon || !moon->valid) return 3;
  if (moon->always_up) return 1;
  if (moon->always_down) return 2;
  return 0;
}

static void persist_save_events_for_home(void) {
  persist_write_int(PERSIST_HOME_YMD, s_home_ymd);
  persist_write_int(PERSIST_HOME_SUN_STATE, sun_state_from_struct(&s_sun_home));
  persist_write_int(PERSIST_HOME_SUNRISE_MIN, s_sun_home.sunrise_min);
  persist_write_int(PERSIST_HOME_SUNSET_MIN, s_sun_home.sunset_min);
  persist_write_int(PERSIST_HOME_MOON_STATE, moon_state_from_struct(&s_moon_home));
  persist_write_int(PERSIST_HOME_MOONRISE_MIN, s_moon_home.moonrise_min);
  persist_write_int(PERSIST_HOME_MOONSET_MIN, s_moon_home.moonset_min);
  if (s_have_moon_phase) {
    persist_write_int(PERSIST_HOME_MOON_PHASE_E6, s_moon_phase_e6);
  }
}

static bool needs_fallback_for_home(void) {
  if (!s_home.valid) return false;
  const int ymd = ymd_for_loc_now(&s_home, NULL, NULL, NULL);
  if (ymd == 0) return false;
  if (s_home_ymd != ymd) return true;
  return !s_sun_home.valid;
}

static void schedule_fallback_calc_if_needed(void);

static void fallback_calc_cb(void *context) {
  (void)context;
  s_fallback_calc_timer = NULL;

  // Determine next needed phase if we're not already mid-run.
  if (s_calc_phase == CALC_PHASE_NONE) {
    if (needs_fallback_for_home()) {
      s_calc_phase = CALC_PHASE_HOME_SUN;
    } else {
      return;
    }
  }

  if (s_calc_phase == CALC_PHASE_HOME_SUN) {
    int y=0,m=0,d=0;
    s_home_ymd = ymd_for_loc_now(&s_home, &y, &m, &d);
    if (s_home_ymd) {
      const double lat = (double)s_home.lat_e6 / 1e6;
      const double lon = (double)s_home.lon_e6 / 1e6;
      s_sun_home = calc_sunrise_sunset_local(y, m, d, lat, lon, s_home.tz_offset_min);
    }
    // Persist only if we already have moon from cache/phone; otherwise keep previous moon values.
    if (s_home_ymd && s_moon_home.valid) {
      persist_save_events_for_home();
    } else if (s_home_ymd) {
      // Still stamp the day so we don't recompute sun repeatedly; moon will remain stale until phone updates.
      persist_write_int(PERSIST_HOME_YMD, s_home_ymd);
      persist_write_int(PERSIST_HOME_SUN_STATE, sun_state_from_struct(&s_sun_home));
      persist_write_int(PERSIST_HOME_SUNRISE_MIN, s_sun_home.sunrise_min);
      persist_write_int(PERSIST_HOME_SUNSET_MIN, s_sun_home.sunset_min);
    }
    s_calc_phase = CALC_PHASE_NONE;
  }

  if (s_canvas_layer) layer_mark_dirty(s_canvas_layer);

  // Continue next phase (slice via timer to avoid blocking)
  schedule_fallback_calc_if_needed();
}

static void schedule_fallback_calc_if_needed(void) {
  if (s_fallback_calc_timer) return;
  // If there is work queued or needed, run soon.
  if (s_calc_phase != CALC_PHASE_NONE || needs_fallback_for_home()) {
    s_fallback_calc_timer = app_timer_register(100, fallback_calc_cb, NULL);
  }
}

static void request_location(void) {
  DictionaryIterator *out;
  if (app_message_outbox_begin(&out) != APP_MSG_OK) return;
  dict_write_uint8(out, MESSAGE_KEY_KEY_REQUEST_LOC, 1);
  dict_write_end(out);
  app_message_outbox_send();
}

static void startup_timer_cb(void *context) {
  (void)context;
  s_startup_timer = NULL;
  request_location();
}

static void inbox_received(DictionaryIterator *iter, void *context) {
  (void)context;
  Tuple *t_lat = dict_find(iter, MESSAGE_KEY_KEY_LAT_E6);
  Tuple *t_lon = dict_find(iter, MESSAGE_KEY_KEY_LON_E6);
  Tuple *t_tz  = dict_find(iter, MESSAGE_KEY_KEY_TZ_OFFSET_MIN);
  Tuple *t_ts  = dict_find(iter, MESSAGE_KEY_KEY_LOC_UNIX);
  Tuple *t_home_sun_state = dict_find(iter, MESSAGE_KEY_KEY_HOME_SUN_STATE);
  Tuple *t_home_sunrise = dict_find(iter, MESSAGE_KEY_KEY_HOME_SUNRISE_MIN);
  Tuple *t_home_sunset = dict_find(iter, MESSAGE_KEY_KEY_HOME_SUNSET_MIN);
  Tuple *t_home_moon_state = dict_find(iter, MESSAGE_KEY_KEY_HOME_MOON_STATE);
  Tuple *t_home_moonrise = dict_find(iter, MESSAGE_KEY_KEY_HOME_MOONRISE_MIN);
  Tuple *t_home_moonset = dict_find(iter, MESSAGE_KEY_KEY_HOME_MOONSET_MIN);
  Tuple *t_moon_phase = dict_find(iter, MESSAGE_KEY_KEY_MOON_PHASE_E6);
  Tuple *t_use_internet = dict_find(iter, MESSAGE_KEY_KEY_USE_INTERNET_FALLBACK);

  bool changed = false;
  if (t_lat && t_lon) {
    s_home.lat_e6 = (int32_t)t_lat->value->int32;
    s_home.lon_e6 = (int32_t)t_lon->value->int32;
    s_home.valid = true;
    persist_write_int(PERSIST_HOME_LAT_E6, s_home.lat_e6);
    persist_write_int(PERSIST_HOME_LON_E6, s_home.lon_e6);
    changed = true;
  }
  if (t_tz) {
    s_home.tz_offset_min = (int32_t)t_tz->value->int32;
    persist_write_int(PERSIST_HOME_TZ_OFFSET_MIN, s_home.tz_offset_min);
    changed = true;
  }
  (void)t_ts;

  if (t_use_internet) {
    s_use_internet_fallback = (t_use_internet->value->uint8 != 0);
    persist_write_int(PERSIST_USE_INTERNET_FALLBACK, s_use_internet_fallback ? 1 : 0);
    changed = true;
  }

  // Home events
  if (t_home_sun_state && t_home_sunrise && t_home_sunset) {
    const int state = (int)t_home_sun_state->value->int32;
    set_sun_from_state_and_minutes(&s_sun_home, state,
                                   (int)t_home_sunrise->value->int32,
                                   (int)t_home_sunset->value->int32);
    changed = true;
  }
  if (t_home_moon_state && t_home_moonrise && t_home_moonset) {
    const int state = (int)t_home_moon_state->value->int32;
    set_moon_from_state_and_minutes(&s_moon_home, state,
                                    (int)t_home_moonrise->value->int32,
                                    (int)t_home_moonset->value->int32);
    changed = true;
  }

  if (t_moon_phase) {
    s_moon_phase_e6 = (int32_t)t_moon_phase->value->int32;
    if (s_moon_phase_e6 < 0) s_moon_phase_e6 = 0;
    if (s_moon_phase_e6 > 1000000) s_moon_phase_e6 = 1000000;
    s_have_moon_phase = true;
    persist_write_int(PERSIST_HOME_MOON_PHASE_E6, s_moon_phase_e6);
    changed = true;
  }

  if (changed) {
    s_last_calc_year = s_last_calc_month = s_last_calc_day = -1;
    // Stamp and persist events when phone provides them.
    if (s_home.valid && (t_home_sun_state || t_home_moon_state)) {
      s_home_ymd = ymd_for_loc_now(&s_home, NULL, NULL, NULL);
      persist_save_events_for_home();
    }
    if (s_canvas_layer) {
      layer_mark_dirty(s_canvas_layer);
    }
    // If phone isn't available or didn't send events, fallback will fill in.
    schedule_fallback_calc_if_needed();
  }

  APP_LOG(APP_LOG_LEVEL_INFO, "inbox_received changed=%d", changed ? 1 : 0);
}

static void tick_handler(struct tm *tick_time, TimeUnits units_changed) {
  (void)units_changed;
  (void)tick_time;
  // If the local day rolled over and the phone isn't around to refresh events,
  // compute daily sun/moon events on-watch.
  if (tick_time && tick_time->tm_min == 0) {
    schedule_fallback_calc_if_needed();
  }
  if (s_canvas_layer) {
    layer_mark_dirty(s_canvas_layer);
  }
}

static void down_long_click_handler(ClickRecognizerRef recognizer, void *context) {
  (void)recognizer; (void)context;
  // Fallback for emulators/keymaps where Select isn't easily accessible.
  s_debug = !s_debug;
  if (s_canvas_layer) {
    layer_mark_dirty(s_canvas_layer);
  }
}

static void down_click_handler(ClickRecognizerRef recognizer, void *context) {
  (void)recognizer; (void)context;
  request_location();
}

static void click_config_provider(void *context) {
  (void)context;
  // Use raw clicks to avoid system Timeline stealing button presses in some emulators.
  window_raw_click_subscribe(BUTTON_ID_DOWN, down_click_handler, down_long_click_handler, NULL);
}

static void canvas_update_proc(Layer *layer, GContext *ctx) {
  const bool have_loc = s_home.valid;
  const bool have_sun = s_sun_home.valid;
  const bool have_moon = s_moon_home.valid;
  yes_draw_canvas(layer, ctx,
                  s_debug,
                  s_use_internet_fallback,
                  have_loc,
                  have_sun,
                  have_moon,
                  s_have_moon_phase,
                  s_moon_phase_e6,
                  active_loc(),
                  active_sun(),
                  active_moon());
}

static void prv_window_load(Window *window) {
  Layer *window_layer = window_get_root_layer(window);
  GRect bounds = layer_get_bounds(window_layer);

  s_canvas_layer = layer_create(bounds);
  layer_set_update_proc(s_canvas_layer, canvas_update_proc);
  layer_add_child(window_layer, s_canvas_layer);
  yes_draw_init();

  APP_LOG(APP_LOG_LEVEL_INFO, "window_load");

  // Defer initial request until after the event loop is fully running.
  if (!s_startup_timer) {
    s_startup_timer = app_timer_register(500, startup_timer_cb, NULL);
  }
}

static void prv_window_unload(Window *window) {
  layer_destroy(s_canvas_layer);
  s_canvas_layer = NULL;
  yes_draw_deinit();
}

static void accel_tap_handler(AccelAxisType axis, int32_t direction) {
  (void)axis; (void)direction;
  s_debug = !s_debug;
  if (s_canvas_layer) {
    layer_mark_dirty(s_canvas_layer);
  }
}

static void prv_init(void) {
  APP_LOG(APP_LOG_LEVEL_INFO, "init");
  // HOME (current phone location)
  s_home.valid = persist_exists(PERSIST_HOME_LAT_E6) && persist_exists(PERSIST_HOME_LON_E6);
  if (s_home.valid) {
    s_home.lat_e6 = persist_read_int(PERSIST_HOME_LAT_E6);
    s_home.lon_e6 = persist_read_int(PERSIST_HOME_LON_E6);
    s_home.tz_offset_min = persist_exists(PERSIST_HOME_TZ_OFFSET_MIN) ? persist_read_int(PERSIST_HOME_TZ_OFFSET_MIN) : 0;
  } else {
    s_home.lat_e6 = 0;
    s_home.lon_e6 = 0;
    s_home.tz_offset_min = 0;
  }

  // Settings from phone config (optional)
  s_use_internet_fallback = persist_exists(PERSIST_USE_INTERNET_FALLBACK) ? (persist_read_int(PERSIST_USE_INTERNET_FALLBACK) != 0) : false;
  s_last_calc_year = s_last_calc_month = s_last_calc_day = -1;
  clear_events();
  s_have_moon_phase = false;
  s_moon_phase_e6 = 0;

  // Load cached daily events if available for today (per-location local date)
  if (s_home.valid && persist_exists(PERSIST_HOME_YMD)) {
    const int ymd_now = ymd_for_loc_now(&s_home, NULL, NULL, NULL);
    const int ymd = persist_read_int(PERSIST_HOME_YMD);
    if (ymd_now != 0 && ymd == ymd_now &&
        persist_exists(PERSIST_HOME_SUN_STATE) && persist_exists(PERSIST_HOME_SUNRISE_MIN) && persist_exists(PERSIST_HOME_SUNSET_MIN) &&
        persist_exists(PERSIST_HOME_MOON_STATE) && persist_exists(PERSIST_HOME_MOONRISE_MIN) && persist_exists(PERSIST_HOME_MOONSET_MIN)) {
      s_home_ymd = ymd;
      set_sun_from_state_and_minutes(&s_sun_home,
                                     persist_read_int(PERSIST_HOME_SUN_STATE),
                                     persist_read_int(PERSIST_HOME_SUNRISE_MIN),
                                     persist_read_int(PERSIST_HOME_SUNSET_MIN));
      set_moon_from_state_and_minutes(&s_moon_home,
                                      persist_read_int(PERSIST_HOME_MOON_STATE),
                                      persist_read_int(PERSIST_HOME_MOONRISE_MIN),
                                      persist_read_int(PERSIST_HOME_MOONSET_MIN));
    }
  }

  if (persist_exists(PERSIST_HOME_MOON_PHASE_E6)) {
    s_moon_phase_e6 = persist_read_int(PERSIST_HOME_MOON_PHASE_E6);
    if (s_moon_phase_e6 < 0) s_moon_phase_e6 = 0;
    if (s_moon_phase_e6 > 1000000) s_moon_phase_e6 = 1000000;
    s_have_moon_phase = true;
  }

  app_message_register_inbox_received(inbox_received);
  app_message_open(256, 256);

  s_window = window_create();
  window_set_click_config_provider(s_window, click_config_provider);
  window_set_window_handlers(s_window, (WindowHandlers) {
    .load = prv_window_load,
    .unload = prv_window_unload,
  });

#ifdef PBL_COLOR
  window_set_background_color(s_window, GColorBlack);
#endif

  const bool animated = true;
  window_stack_push(s_window, animated);

  tick_timer_service_subscribe(MINUTE_UNIT, tick_handler);
  accel_tap_service_subscribe(accel_tap_handler);

  // Ask phone for location (and it will also send sun/moon event times)
  // done via startup timer in window_load
  // Fallback: if phone isn't around, compute daily events on-watch.
  schedule_fallback_calc_if_needed();
}

static void prv_deinit(void) {
  tick_timer_service_unsubscribe();
  accel_tap_service_unsubscribe();
  if (s_fallback_calc_timer) {
    app_timer_cancel(s_fallback_calc_timer);
    s_fallback_calc_timer = NULL;
  }
  s_calc_phase = CALC_PHASE_NONE;
  if (s_startup_timer) {
    app_timer_cancel(s_startup_timer);
    s_startup_timer = NULL;
  }
  window_destroy(s_window);
}

int main(void) {
  prv_init();

  app_event_loop();
  prv_deinit();
}

